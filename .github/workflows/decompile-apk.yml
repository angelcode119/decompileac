name: Decompile APK and send to Telegram

on:
  workflow_dispatch:
    inputs:
      apk-path:
        description: Path to the APK to decompile
        required: false
        default: app.apk
      so-path:
        description: Path to the native library (.so) to analyze
        required: false
        default: libnative.so
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  decompile:
    runs-on: ubuntu-latest
    env:
      APK_PATH: ${{ github.event.inputs.apk-path || 'app.apk' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify APK exists
        run: |
          echo "Using APK_PATH=$APK_PATH"
          if [ ! -f "$APK_PATH" ]; then
            echo "APK not found at $APK_PATH" >&2
            exit 1
          fi
          ls -lh "$APK_PATH"
        shell: bash

      - name: Download jadx
        run: |
          set -euo pipefail
          JADAX_VERSION="1.5.1"
          mkdir -p tools
          curl -L -o tools/jadx.zip "https://github.com/skylot/jadx/releases/download/v${JADAX_VERSION}/jadx-${JADAX_VERSION}.zip"
          unzip -q tools/jadx.zip -d tools/jadx
          echo "JADX_BIN=${GITHUB_WORKSPACE}/tools/jadx/bin/jadx" >> "$GITHUB_ENV"
        shell: bash

      - name: Decompile APK with jadx
        run: |
          set -uo pipefail
          OUTPUT_DIR="decompiled"
          mkdir -p "$OUTPUT_DIR"
          # Full decompilation options:
          # --show-bad-code : keep problematic code blocks instead of skipping
          # --export-gradle : also emit a gradle-style project
          # --deobf*        : light deobfuscation to stabilize names
          if ! "$JADX_BIN" \
            --show-bad-code \
            --export-gradle \
            --deobf \
            --deobf-min 3 \
            --deobf-max 150 \
            -d "$OUTPUT_DIR" \
            "$APK_PATH" >jadx.log 2>&1; then
            echo "jadx finished with errors; see jadx.log (continuing)" >&2
          fi
          tail -n 80 jadx.log || true
          FILE_COUNT=$(find "$OUTPUT_DIR" -type f | wc -l | tr -d ' ')
          if [ "$FILE_COUNT" = "0" ]; then
            echo "No output files produced by jadx; failing to avoid empty artifact" >&2
            exit 1
          fi
          echo "Decompiled files: $FILE_COUNT"
          find "$OUTPUT_DIR" -maxdepth 2 -type f | head -n 20
        shell: bash

      - name: Zip decompiled sources
        run: |
          set -euo pipefail
          zip -qr decompiled.zip decompiled
        shell: bash

      - name: Upload artifact (decompiled.zip)
        uses: actions/upload-artifact@v4
        with:
          name: decompiled-apk
          path: decompiled.zip
          retention-days: 7

      - name: Send to Telegram
        if: ${{ success() }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN}" ] || [ -z "${TELEGRAM_CHAT_ID}" ]; then
            echo "Telegram secrets not configured; skipping send." >&2
            exit 0
          fi
          curl -sS -X POST \
            -F "chat_id=${TELEGRAM_CHAT_ID}" \
            -F "caption=Decompiled APK from ${{ github.repository }}@${{ github.sha }}" \
            -F "document=@decompiled.zip" \
            "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument"
        shell: bash

  analyze_so:
    runs-on: ubuntu-latest
    needs: decompile
    env:
      SO_PATH: ${{ github.event.inputs.so-path || 'libnative.so' }}
      APK_PATH: ${{ github.event.inputs.apk-path || 'app.apk' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Collect .so files
        run: |
          echo "Requested SO_PATH=$SO_PATH"
          echo "APK_PATH=$APK_PATH"

          SO_LIST=so_targets.txt
          > "$SO_LIST"

          add_if_exists() {
            local path="$1"
            if [ -f "$path" ]; then
              realpath "$path"
            elif [ -d "$path" ]; then
              find "$path" -type f -name '*.so'
            fi
          }

          add_if_exists "$SO_PATH" >> "$SO_LIST"
          add_if_exists "lib" >> "$SO_LIST"
          find . -type f -name '*.so' -not -path '*/.git/*' >> "$SO_LIST"

          if [ ! -s "$SO_LIST" ] && [ -f "$APK_PATH" ]; then
            echo "Extracting .so files from APK: $APK_PATH"
            mkdir -p extracted_libs
            unzip -qq "$APK_PATH" "lib/*.so" -d extracted_libs || true
            find extracted_libs -type f -name '*.so' >> "$SO_LIST"
          fi

          sort -u "$SO_LIST" -o "$SO_LIST"

          if [ ! -s "$SO_LIST" ]; then
            echo "No .so found (checked explicit path/dir, lib/**, repo, and APK libs)" >&2
            exit 1
          fi

          echo "Will analyze these .so files:"
          cat "$SO_LIST"
          echo "SO_LIST=$SO_LIST" >> "$GITHUB_ENV"
        shell: bash

      - name: Install cross binutils (for objdump on ARM/x86)
        run: |
          sudo apt-get update -y
          sudo apt-get install -y binutils-aarch64-linux-gnu binutils-arm-linux-gnueabi
        shell: bash

      - name: Analyze .so (metadata, symbols, disasm)
        run: |
          set -euo pipefail
          OUT=so-report
          mkdir -p "$OUT"
          idx=0
          while IFS= read -r sofile; do
            [ -n "$sofile" ] || continue
            safe_name="so-${idx}-$(basename "$sofile" | tr -cs 'A-Za-z0-9._-' '_')"
            dest="$OUT/$safe_name"
            mkdir -p "$dest"

            FILE_INFO="$(file "$sofile")"
            echo "$FILE_INFO" | tee "$dest/file.txt"
            readelf -a "$sofile" > "$dest/readelf.txt" || true
            nm -D "$sofile" > "$dest/nm.txt" || true

            OBJDUMP_CMD="objdump -d -C"
            if echo "$FILE_INFO" | grep -qi "ARM aarch64"; then
              OBJDUMP_CMD="aarch64-linux-gnu-objdump -d -C"
            elif echo "$FILE_INFO" | grep -qi "ARM"; then
              OBJDUMP_CMD="arm-linux-gnueabi-objdump -d -C"
            fi

            if ! $OBJDUMP_CMD "$sofile" > "$dest/objdump.txt"; then
              echo "objdump failed with $OBJDUMP_CMD for $sofile (logged), continuing" >&2
            fi

            strings "$sofile" > "$dest/strings.txt" || true
            idx=$((idx+1))
          done < "$SO_LIST"

          zip -qr so-analysis.zip "$OUT"
        shell: bash

      - name: Upload artifact (so-analysis.zip)
        uses: actions/upload-artifact@v4
        with:
          name: so-analysis
          path: so-analysis.zip
          retention-days: 7

      - name: Send .so analysis to Telegram
        if: ${{ success() }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN}" ] || [ -z "${TELEGRAM_CHAT_ID}" ]; then
            echo "Telegram secrets not configured; skipping send." >&2
            exit 0
          fi
          curl -sS -X POST \
            -F "chat_id=${TELEGRAM_CHAT_ID}" \
            -F "caption=SO analysis from ${{ github.repository }}@${{ github.sha }}" \
            -F "document=@so-analysis.zip" \
            "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument"
        shell: bash

