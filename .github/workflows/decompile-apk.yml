name: Decompile APK and send to Telegram

on:
  workflow_dispatch:
    inputs:
      apk-path:
        description: Path to the APK to decompile
        required: false
        default: app.apk
      so-path:
        description: Path to the native library (.so) to analyze
        required: false
        default: libnative.so
  push:
    branches:
      - main

permissions:
  contents: read

jobs:
  decompile:
    runs-on: ubuntu-latest
    env:
      APK_PATH: ${{ github.event.inputs.apk-path || 'app.apk' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify APK exists
        run: |
          echo "Using APK_PATH=$APK_PATH"
          if [ ! -f "$APK_PATH" ]; then
            echo "APK not found at $APK_PATH" >&2
            exit 1
          fi
          ls -lh "$APK_PATH"
        shell: bash

      - name: Download jadx
        run: |
          set -euo pipefail
          JADAX_VERSION="1.5.1"
          mkdir -p tools
          curl -L -o tools/jadx.zip "https://github.com/skylot/jadx/releases/download/v${JADAX_VERSION}/jadx-${JADAX_VERSION}.zip"
          unzip -q tools/jadx.zip -d tools/jadx
          echo "JADX_BIN=${GITHUB_WORKSPACE}/tools/jadx/bin/jadx" >> "$GITHUB_ENV"
        shell: bash

      - name: Decompile APK with jadx
        run: |
          set -uo pipefail
          OUTPUT_DIR="decompiled"
          mkdir -p "$OUTPUT_DIR"
          # Full decompilation options:
          # --show-bad-code : keep problematic code blocks instead of skipping
          # --export-gradle : also emit a gradle-style project
          # --deobf*        : light deobfuscation to stabilize names
          if ! "$JADX_BIN" \
            --show-bad-code \
            --export-gradle \
            --deobf \
            --deobf-min 3 \
            --deobf-max 150 \
            -d "$OUTPUT_DIR" \
            "$APK_PATH" >jadx.log 2>&1; then
            echo "jadx finished with errors; see jadx.log (continuing)" >&2
          fi
          tail -n 80 jadx.log || true
          FILE_COUNT=$(find "$OUTPUT_DIR" -type f | wc -l | tr -d ' ')
          if [ "$FILE_COUNT" = "0" ]; then
            echo "No output files produced by jadx; failing to avoid empty artifact" >&2
            exit 1
          fi
          echo "Decompiled files: $FILE_COUNT"
          find "$OUTPUT_DIR" -maxdepth 2 -type f | head -n 20
        shell: bash

      - name: Zip decompiled sources
        run: |
          set -euo pipefail
          zip -qr decompiled.zip decompiled
        shell: bash

      - name: Upload artifact (decompiled.zip)
        uses: actions/upload-artifact@v4
        with:
          name: decompiled-apk
          path: decompiled.zip
          retention-days: 7

      - name: Send to Telegram
        if: ${{ success() }}
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN}" ] || [ -z "${TELEGRAM_CHAT_ID}" ]; then
            echo "Telegram secrets not configured; skipping send." >&2
            exit 0
          fi
          curl -sS -X POST \
            -F "chat_id=${TELEGRAM_CHAT_ID}" \
            -F "caption=Decompiled APK from ${{ github.repository }}@${{ github.sha }}" \
            -F "document=@decompiled.zip" \
            "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendDocument"
        shell: bash

  analyze_so:
    runs-on: ubuntu-latest
    needs: decompile
    env:
      SO_PATH: ${{ github.event.inputs.so-path || 'libnative.so' }}
      APK_PATH: ${{ github.event.inputs.apk-path || 'app.apk' }}
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Verify .so exists
        run: |
          echo "Requested SO_PATH=$SO_PATH"
          echo "APK_PATH=$APK_PATH"

          pick_so() {
            local path="$1"
            if [ -n "$path" ] && [ -f "$path" ]; then
              echo "$path"
              return 0
            fi
            return 1
          }

          FINAL_SO=""

          # 1) honor explicit path if it exists
          if pick_so "$SO_PATH"; then
            FINAL_SO="$SO_PATH"
          fi

          # 2) try common lib directory inside repo
          if [ -z "$FINAL_SO" ]; then
            FINAL_SO="$(find lib -type f -name '*.so' 2>/dev/null | head -n 1 || true)"
          fi

          # 3) try anywhere in repo (excluding .git)
          if [ -z "$FINAL_SO" ]; then
            FINAL_SO="$(find . -type f -name '*.so' -not -path '*/.git/*' | head -n 1 || true)"
          fi

          # 4) extract from APK libs if still not found
          if [ -z "$FINAL_SO" ] && [ -f "$APK_PATH" ]; then
            echo "Extracting .so files from APK: $APK_PATH"
            mkdir -p extracted_libs
            unzip -qq "$APK_PATH" "lib/*.so" -d extracted_libs || true
            FINAL_SO="$(find extracted_libs -type f -name '*.so' | head -n 1 || true)"
          fi

          if [ -z "$FINAL_SO" ]; then
            echo "No .so found (checked explicit path, lib/**, repo, and APK libs)" >&2
            exit 1
          fi

          echo "Selected SO: $FINAL_SO"
          ls -lh "$FINAL_SO"
          echo "FINAL_SO=$FINAL_SO" >> "$GITHUB_ENV"
        shell: bash

      - name: Analyze .so (metadata, symbols, disasm)
        run: |
          set -euo pipefail
          OUT=so-report
          mkdir -p "$OUT"
          file "$FINAL_SO" | tee "$OUT/file.txt"
          readelf -a "$FINAL_SO" > "$OUT/readelf.txt"
          nm -D "$FINAL_SO" > "$OUT/nm.txt"
          objdump -d -C "$FINAL_SO" > "$OUT/objdump.txt"
          strings "$FINAL_SO" > "$OUT/strings.txt"
          zip -qr so-analysis.zip "$OUT"
        shell: bash

      - name: Upload artifact (so-analysis.zip)
        uses: actions/upload-artifact@v4
        with:
          name: so-analysis
          path: so-analysis.zip
          retention-days: 7

